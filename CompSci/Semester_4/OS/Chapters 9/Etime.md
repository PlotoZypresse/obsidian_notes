![[Screenshot 2024-03-14 at 14.25.39.png]]
- physical adresses are the real adresses in the physical memory. where as logical adresses are generated by the cpu. the logical adress is loaded in to the memory adress register and translated to a physical adress
- 

![[Screenshot 2024-03-14 at 14.28.21.png]]
- The selection of a power of 2 as a page size makes the translation of a logical address into a page number and page offset particularly easy. If the size of the logical address space is 2m, and a page size is 2n bytes, then the high-order mâˆ’n bits of a logical address designate the page number, and the n low-order bits designate the page offset.

![[Screenshot 2024-03-14 at 14.29.40.png]]
- if the instructions are read only we only need one instance of the code in memory and all the different useres have access to it this is great when memory is limited. But there can be no changes to the instruxtions which could be use full if there where only one user using the programm
- more complex to manage 
![[Screenshot 2024-03-14 at 14.35.32.png]]
a. Logical Address:
- Number of pages, $P = 64$
- Words per page, $W = 1024$
- Bits for page number, $B_{page} = \log_2(P) = \log_2(64) = 6$
- Bits for offset, $B_{offset} = \log_2(W) = \log_2(1024) = 10$
- Total bits for logical address, $B_{logical} = B_{page} + B_{offset} = 6 + 10 = 16$

b. Physical Address:
- Number of frames, $F = 32$
- Bits for frame number, $B_{frame} = \log_2(F) = \log_2(32) = 5$
- Bits for offset is the same as logical address, $B_{offset} = 10$
- Total bits for physical address, $B_{physical} = B_{frame} + B_{offset} = 5 + 10 = 15$


![[Screenshot 2024-03-14 at 14.52.42.png]]
- instead of doing a byte by byte copy we can instead create a new page table that points to the same physical memory vastly speeding up copy time
- we can also use it for interprocess comunication
- when updating one byte all process can see it as they all point to the same physical memory

![[Screenshot 2024-03-14 at 15.19.10.png]]
- first fit places the processs in the first free memory space where the process fits
- best fit looks for the one where space is optimally used
	- process one with 115KB would be put in 125KB for example 
- worst fit takes the one where it fits worst
	- process one with 115KB would be put in 750KB slot

![[Screenshot 2024-03-14 at 15.36.31.png]]
For a 1-KB (1024 bytes) page size, the page number and offset can be calculated as follows:

a. Address = 3085
- Page Number: $3085 \div 1024$
- Offset: $3085 \mod 1024$

b. Address = 42095
- Page Number: $42095 \div 1024$
- Offset: $42095 \mod 1024$

c. Address = 215201
- Page Number: $215201 \div 1024$
- Offset: $215201 \mod 1024$

d. Address = 650000
- Page Number: $650000 \div 1024$
- Offset: $650000 \mod 1024$

e. Address = 2000001
- Page Number: $2000001 \div 1024$
- Offset: $2000001 \mod 1024$
![[Screenshot 2024-03-14 at 16.43.21.png]]
a. For a conventional, single-level page table:

- A 21-bit virtual address space implies that there are 2^21 different addresses.
- With a page size of 2 KB (which is 211211 bytes), the number of pages in the virtual address space is 2^21/2^11=2^10 2^21/2^11=2^10.
- Therefore, a single-level page table would need one entry for each page in the virtual address space, which means it would have 2^10 entries.

b. For an inverted page table:

- An inverted page table typically has one entry for each frame of physical memory, not for each page of virtual address space.
- With a 16-bit physical address space, there are 216216 different addresses.
- Since the physical memory is addressed by bytes and the page size is 2 KB, the number of frames in the physical memory is 216/211=25216/211=25.
- Therefore, the inverted page table would have 2525 entries.

The maximum amount of physical memory in the BTV operating system would be determined by its 16-bit physical address space, which can address up to 216216 locations. Since each location is addressed by bytes, the maximum physical memory is 216216 bytes, or 64 KB.

a. Conventional, single-level page table:
- Entries: $2^{10}$

b. Inverted page table:
- Entries: $2^5$

Maximum physical memory in the BTV operating system:
- $2^{16}$ bytes, or 64 KB

![[Screenshot 2024-03-14 at 17.11.41.png]]
a. Logical Address:
- The logical address space consists of 256 pages. To address 256 pages, we need $\log_2(256) = 8$ bits.
- Each page is 4-KB, which is $2^{12}$ bytes, so we need 12 bits to address the bytes within a page.
- Therefore, the total number of bits required for the logical address is $8$ (for the page number) + $12$ (for the offset within the page), which equals $20$ bits.

b. Physical Address:
- The physical memory is composed of 64 frames, so we need $\log_2(64) = 6$ bits to address each frame.
- Since the page size is the same as the frame size, the offset size is also 12 bits.
- Therefore, the total number of bits required for the physical address is $6$ (for the frame number) + $12$ (for the offset within the frame), which equals $18$ bits.

![[Screenshot 2024-03-14 at 17.27.41.png]]
a. Conventional, single-level page table:
- With a 32-bit logical address space, we can address $2^{32}$ locations.
- Since the page size is 4-KB, or $2^{12}$ bytes, we have $2^{32} / 2^{12} = 2^{20}$ pages.
- Therefore, a conventional single-level page table would need one entry per page, resulting in $2^{20}$ entries.

b. An inverted page table:
- The system supports up to 512 MB of physical memory, which is $512 \times 2^{20}$ bytes (since 1 MB = $2^{20}$ bytes).
- With a page size of 4-KB, the total number of frames is $512 \times 2^{20} / 2^{12} = 2^{29} / 2^{12} = 2^{17}$.
- An inverted page table has one entry for each frame in physical memory, so it would have $2^{17}$ entries.

![[Screenshot 2024-03-14 at 17.30.20.png]]
- internal fragmentation is when we give process more memory than it needs because of our page size. Its called internal because its inside the memeory block of the program
- externel fragmentation is when a process is loaded into a free memory block but it doesnt fill out the whole block. Over time we can get many small blocks of memory that are free but no individual block is big eneough for a new process even though there is enough memory avcailiable. Just not in one pice
![[Screenshot 2024-03-14 at 17.36.20.png]]
- just like the previus 

![[Screenshot 2024-03-14 at 17.37.01.png]]
- Dynamic memory allocation allows a program to allocate more memory to its address space during execution. Here's what is required to support dynamic memory allocation for both contiguous memory allocation and paging:

a. **Contiguous Memory Allocation**:
- Memory management unit (MMU) that can allocate a single contiguous block of memory addresses to a process.
- A dynamic storage-allocation algorithm (e.g., first-fit, best-fit, worst-fit) to find a free block of memory that is large enough for the requested allocation.
- The operating system must keep track of all free and allocated spaces, which might be done using a free space list or bitmap.
- Defragmentation utilities may be required over time to combat external fragmentation, which can prevent large contiguous spaces from being available even when enough total memory is free.

b. **Paging**:
- Support for paging requires an MMU capable of translating logical addresses to physical addresses using a page table.
- The operating system manages memory in fixed-size blocks called pages, which eliminates the need for contiguous allocation in physical memory.
- A page table for each process, which keeps track of the mapping from the process's pages to the available frames in physical memory.
- Dynamic allocation of pages as a process grows, which may involve adding page table entries and possibly extending the page table.
- Some mechanism for page replacement (such as Least Recently Used (LRU) or First-In-First-Out (FIFO)) if physical memory becomes full and pages need to be swapped out to disk (paging or swapping).

For both schemes, the operating system typically uses a combination of hardware and software features to manage memory. The key difference between them is how they handle fragmentation: contiguous allocation must deal with external fragmentation, while paging naturally avoids it by allowing non-contiguous physical memory allocation.

![[Screenshot 2024-03-14 at 17.37.52.png]]
- they do not support swapping in the classical sence becuase flash memory has limited read and write amounts. In a mobile system with little memory we would swap all the time stressing the flash storage and imensly deprecating its lifespan

![[Screenshot 2024-03-14 at 17.39.35.png]]
For a 1-KB (1024 bytes) page size, the page number and offset for each address are:

a. Address = 21205
- Page Number: $21205 \div 1024$
- Offset: $21205 \mod 1024$

b. Address = 164250
- Page Number: $164250 \div 1024$
- Offset: $164250 \mod 1024$

c. Address = 121357
- Page Number: $121357 \div 1024$
- Offset: $121357 \mod 1024$

d. Address = 16479315
- Page Number: $16479315 \div 1024$
- Offset: $16479315 \mod 1024$

e. Address = 27253187
- Page Number: $27253187 \div 1024$
- Offset: $27253187 \mod 1024$


![[Screenshot 2024-03-14 at 17.41.14.png]]
a. Logical Address:
- The logical address space has 2,048 pages. To address these, we need $\log_2(2048) = 11$ bits.
- Each page is 4-KB, which is $2^{12}$ bytes, so we need 12 bits to address the bytes within a page.
- Therefore, the total number of bits required for the logical address is $11$ (for the page number) + $12$ (for the offset within the page), which equals $23$ bits.

b. Physical Address:
- The physical memory is composed of 512 frames, so we need $\log_2(512) = 9$ bits to address each frame.
- Since the page size is the same as the frame size, the offset size is also 12 bits.
- Therefore, the total number of bits required for the physical address is $9$ (for the frame number) + $12$ (for the offset within the frame), which equals $21$ bits.

![[Screenshot 2024-03-14 at 17.41.28.png]]
a. Conventional, single-level page table:
- A 32-bit logical address space means there are $2^{32}$ possible addresses.
- With an 8-KB page size, which is $2^{13}$ bytes, the number of pages is $2^{32} / 2^{13} = 2^{19}$.
- Thus, a conventional page table that covers the entire logical address space would require $2^{19}$ entries, one for each page.

b. An inverted page table:
- The system has 1 GB of physical memory, which is $2^{30}$ bytes.
- With an 8-KB page size, the total number of frames is $2^{30} / 2^{13} = 2^{17}$.
- An inverted page table has one entry per frame of physical memory, so it would need $2^{17}$ entries.

![[Screenshot 2024-03-14 at 17.41.40.png]]