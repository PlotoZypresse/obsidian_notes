#### Related to Chapter 1
1. What are the three main purposes of an operating system?
	- execute user programms
	- use computer hardware in an efficent manner
	- make it easy to use
1. What is the main difficulty that a programmer must overcome in writing an operating system for a real-time environment?
	- processing needs to be done in a timely manner. there are strict deadlines
	- 
 1. Keeping in mind the various definitions of operating system, consider whether the operating system should include applications such as web browsers and mail programs. Argue both that it should and that it should not, and support your answers.
	- If they should is almost about personal preference or use case. An OS for the people which is used by grandmas and other people a webbrowser would be a great idea as grandma probably doesn't know how to install anything. For an OS that is used for a machine or a server a webbrowser is probably not required as its either not used or the user knows how to install it.

4. How does the distinction between kernel mode and user mode function as a rudimentary form of protection (security)?
	Specific high risk "tasks" can only be done in kernel mode so that a user for example cant delete their operating system by accident
	- access managment
	- 

5. Which of the following instructions should be privileged?

	- Set value of timer.
		p
	- Read the clock.
		n
	- Clear memory.
		p
	-  Issue a trap instruction.
		 n
	-  Turn off interrupts.
		p
	- Modify entries in device-status table.
		p
	-  Switch from user to kernel mode.
		p
	-  Access I/O device.
		 p

 6. Some CPUs provide for more than two modes of operation. What are two possible uses of these multiple modes?
		User and kernel mode. Switching between them is often done with a hardware bit
	-  virtualization
	- 

7. Give two reasons why caches are useful. What problems do they solve? What problems do they cause? If a cache can be made as large as the device for which it is caching (for instance, a cache as large as a disk), why not make it that large and eliminate the device?

	- Caches are good because they are fast. They are not so good because they have a small size and are expensive. Thats why we have the memory hirachy that tries to optimize this problem with the given constraints.
	- Cache coherrency
1.  How do clustered systems differ from multiprocessor systems? What is required for two machines belonging to a cluster to cooperate to provide a highly available service?

	- Cluster systems are multiple "computers" connected together. Multiprocessor systems are one "computer" with as the name implies multiple processors

2.  **(important)** What is the purpose of interrupts? How does an interrupt differ from a trap? Can traps be generated intentionally by a user program? If so, for what purpose?

	 - **Purpose of Interrupts**: Interrupts serve the crucial purpose of enabling the CPU to respond to asynchronous events. These events could be external, such as input from a keyboard or a network packet arrival, or internal, such as a timer expiring. By interrupting the current process, the CPU can address these events in a timely manner, which is essential for real-time processing and efficient multitasking. This mechanism ensures that the operating system can manage resources effectively, providing a responsive computing environment.
    
	- **Difference Between Interrupts and Traps**: 
    - **Interrupts** are generally initiated by hardware devices or are software interrupts triggered by the execution of specific instructions, aiming to handle external and internal events that require immediate attention.
    - **Traps**, on the other hand, are a specific kind of interrupt that are intentionally generated by the CPU as a result of executing a particular instruction. Traps are used to handle exceptional conditions such as division by zero, invalid memory access, or explicitly by a user program to invoke operating system services via system calls.
	- **Intentional Generation of Traps by User Programs**: Yes, traps can indeed be generated intentionally by user programs, primarily through system calls. System calls are a way for programs to request services from the operating system, such as file operations, process management, networking, and more. When a program executes a system call instruction, it triggers a trap to the operating system, which then takes over to execute the requested service. This mechanism is fundamental to the operation of modern operating systems, enabling user programs to perform operations beyond their direct control in a secure and managed way.

10. Direct memory access is used for high-speed I/O devices in order to avoid increasing the CPU’s execution load.
    
    -  How does the CPU interface with the device to coordinate the transfer?
		DMA(Direct Memory Access)
	-  How does the CPU know when the memory operations are complete?
		When the data is transferred only one interrupt is send to the CPU 
    - The CPU is allowed to execute other programs while the DMA controller is transferring data. Does this process interfere with the execution of the user programs? If so, describe what forms of interference are caused.
	    - No it does not interfere

11. Rank the following storage systems from slowest to fastest:

	- Hard-disk drives x
	- Registers
	- Optical disk x
	- Main memory x
	- Nonvolatile memory x
	- Magnetic tapes x
	- Cache

- 1. magnetic tapes 2. Optical disk 3. Hsrddisk drives 4. nonvolatile memory 5. Main memory 6. Cache 7. Registers

12. Describe some of the challenges of designing operating systems for mobile devices compared with designing operating systems for traditional PCs.
	- performance and battery constraints, storage, power managing, tempreature

#### Related to Chapter 2

1. **(important)** What is the purpose of system calls?
	- system calls pserve as an interface between the OS and user software. System calls allows user programms to perforem specific operations than are not directly accessible as a protection mechanism. A system call could be to open a file

2.  What system calls have to be executed by a command interpreter or shell in order to start a new process on a UNIX system?
	- fork()
	

3.  What is the purpose of system programs?
	- the purpose of system programs is to give the code to do a specific task for example the command rm to remove a file is implemented as a system program saved in the file called rm in the file is some code that takes a file name and deletes the data.

4. What is the main advantage of the layered approach to system design? What are the disadvantages of the layered approach?
	- the advantage of the layered approach is simplicity of construction and debugging. The layers are desigend so that each layer only uses functions from lower level layers. this in return makes it easier to debug(kinda like the chain rule)

5. List three services provided by an operating system, and explain how each creates convenience for users. In which cases would it be impossible for user-level programs to provide these services? Explain your answer.
	- 

1. How could a system be designed to allow a choice of operating systems from which to boot? What would the bootstrap program need to do?
	- the bootstrap program would need to get info about which operating system to boot and then be able to locate and load the specified code
	- use of a boot loader like grub

1. What are the advantages and disadvantages of using the same system-call interface for manipulating both files and devices?
	- 
1. Describe why Android uses ahead-of-time (AOT) rather than just-in-time (JIT) compilation.
	- AOT compiles the program binary ahead of time just like we would do with a c program on a computer. THis is good as it saves resurces
1. How are iOS and Android similar? How are they different?
	- 
1. What are the two models of interprocess communication? What are the strengths and weaknesses of the two approaches?
	- the two models are Message-Parsing and Shared memory.
	- 1. **Message Passing**:
    
    - **Strengths**:
        - **Decoupling of Processes**: Processes do not need to share memory or state, making the system architecture simpler and more modular.
        - **Flexibility**: Easily implemented across different systems, including distributed systems where processes run on different machines.
        - **Simplicity**: Straightforward for developers to use, as the complexity of synchronization is often handled by the underlying IPC mechanism.
        - **Security**: Provides a higher level of security as processes do not have direct access to each other's memory spaces.
    - **Weaknesses**:
        - **Overhead**: Can introduce significant overhead due to message encoding/decoding and system calls, impacting performance.
        - **Complexity in Message Management**: Requires careful design to manage message formats and protocols, especially in systems with diverse communication patterns.
        - **Latency**: May have higher latency compared to shared memory, especially for large volumes of data.
2. **Shared Memory**:
    
    - **Strengths**:
        - **Performance**: Offers high-speed communication by avoiding the overhead of message passing systems, as data does not need to be copied between the sender and receiver.
        - **Efficiency**: More efficient for transferring large amounts of data, as it avoids the overhead of system calls once the memory is mapped.
        - **Direct Access**: Processes can directly read and write to the shared memory region, allowing for complex data structures to be shared.
    - **Weaknesses**:
        - **Complexity in Synchronization**: Requires explicit synchronization mechanisms (like semaphores or mutexes) to prevent race conditions, making the implementation more complex.
        - **Security Risks**: Increases the risk of unintentional interference between processes, as well as security vulnerabilities, since processes have direct access to shared memory.
        - **Coupling of Processes**: Processes are more tightly coupled to each other, which can complicate system design and maintenance.

3. What is the main advantage of the microkernel approach to system design? How do user programs and system services interact in a micro-kernel architecture? What are the disadvantages of using the microkernel approach?