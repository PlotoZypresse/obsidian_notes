- Memory adresses
- Logical adresses
- Physical adresses
- Dynamic loading and linking
- memory protection
- memory allocation
- fragmentation
- Paging
	- Basic methode
	- hardware support
	- Protection
	- shared pages
- Hirachal paging
- Hashed page tables
- inverted page tables
- Swapping


Main Memory
- Every byte in the memory has an address. Its a large array of bytes, each with its own address
- Main memory and the registers build into the CPU are the only general purpose storage that the CPU can access directly.
- To ensure that a process only accesses its intended memory we can define a base and limit register. The base register is the smallest legal physical adress and the limit register specifies the size of the range. Meaning that base+limit is the biggest address.
- Security is done by the cpu comparing every address from user code with this![[Screenshot 2024-06-18 at 14.56.49.png]]
- In kernel mode the OS has unrestriced access to the memory
- Memory addresses  are not defined in user code.
	- if we know at compile time where the process will reside in memory then absolute code can be generated. We know where the code will be and can there  fore give a precise starting location. But if that changes we have to recompile
	- If we do not know at compile time where the process will be located the compiler will need to generate relocatable code. Final binding is the delayed uuntil load time. If the starting address changes we only need to reload the user code
	- If the process  can be moved during execution the binding must be delayed until runtime. We need special hardware for this to work. This is mostly used

Logical and Physical adress space
- The address generated by the CPU is the logical address also called virtual address. The physical address is the one seen by the memory unit. If addresses are binded at compile or load time Physical and logical addresses are identical. The execution time adress binding scheme results in different addresses.
- THe mapping from physical to logical memory is done by the memory-managment unit (MMU). There are differnet methodes to accomplish this mapping.![[Screenshot 2024-06-18 at 15.19.08.png]]
- an easy implementation is where we use the base register to map the physical addresses to logical addresses. In this case the base register is called the relocation register. We simply add the base register to the logical adress to get the physical address![[Screenshot 2024-06-18 at 15.21.15.png]]
- Dynamic loading and linking
	- When using dynamic loading we only load a a routine of our program if it is called. this optimizes memory usage
	- We also just load librarys once instead of for every process

Contiguous Memory allocation
- Memory is usualy divided into two partions one for the OS and one for user processes. With contiguous memory allocation a process gets single contiguous block of memory. This methode has some advantages. Becaus every process has one block of memory its easy to handle memory protection because we just need to check if the address is in the processes address space. The MMU gets the virtual address from the cpu checks if it is smaller than the limit register adds the base/realocation register to it and we get the physical address.
- Since all memory is in one block access speed is also fast.

- If we only had a couple of processes that started at the begining this methode would suffice. But because we constantly move processes in and out of memory we end up with holes in memory.
- ![[Screenshot 2024-06-18 at 15.52.41.png]]
- To optimize usage of these holes there are different techniques. Three of the most used ones are
	- First fit: Here we allocate the process to the first hole thats big enough
	- Best fit: Here we find the smalles hole that is big enough for our process
	- Worst fit: Here we find the largest hole in the memory
- All this can lead to memory fragmentation. Fragmentation is when we end up with holes in our memory. At some point we have enough space in memory for a new process but there is not a big enough continues memory segment to load the process. This is called external fragmentation. There is also internal fragmentation. This happens when we allocate more memory to a process than it needs
- A solution to externel fragmentation is compaction. Here we take all the scattered memory blocks and make them to one big block

Paging
- thus far the address space of a process had to be continuous. With paging this is not the case anymore
- When using paging the physical memory is divided into fixed size blocks called frames and logical memory is divided into same size blocks called pages. So when a process is executed its pages are loaded into any available memory frames
- Every address generated by the cpu is now different. its divided into page number and a page offset
- ![[Screenshot 2024-06-18 at 16.20.18.png]]
- The page number is used as an index into a per-process page table. The page table contains the base address of each frame in physical memory. The offset is the location in the frame being referenced. Thus the base address of the frame is combined with the page offset to define the physical memory address
- The page table is a data structure used by the operating system to keep track of the mapping between virtual pages and physical frames. Each process has its own page table.
- The MMU need to take the following steps to translate a logical address from the CPU to a physical address
	- Extract the page number and use it as an index into the page table
	- Extract the corresponding fram number from the page table
	- replace the page number p in logical address with the frame number
![[Screenshot 2024-06-18 at 16.25.16.png]]
- If the logical address space is $2^m$ and the page size is $2^n$ then the lower n bits in the logical address are the page offset and thhe upper m-n bitss are the page number
- **Hardware support**
	- Instead of having the page table in registers or in memory. The first one has a size constraint the second one a speed. We us a translation look-aside buffer(TBL). The TBL is highspeed memory. Each entry in the TBL consists of a key and a value. Because the TBL has associative memory, when an item is presented to the TBL it is automaticly compared with every item in the TBL. If the item is found the value is returned.
	- When the CPU generates a logical address the MMU first checks if its page number is in the TBL if it is the frame number is immedatily available and is used. If it is not found the process is just like normal and we add the frame number to the TBL for future use.
	- If the TBL is full we need to replace an existing entry. For this there are different replacement policeies like LRU or random. Kinda like cache
![[Screenshot 2024-06-18 at 17.12.16.png]]


Swapping
- Swapping is when we swap a portion of a process from memory into storage and then bring it back if we need it again. Sapping makes it possible for the total address space for all processes to exceed the real physical address space
- Standard swapping
	- standard swapping moves the hole process into storage
- We can also swap pages in and out of storage